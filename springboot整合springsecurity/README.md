# Springboot整合springsecurity

### 简介

我们知道，**登录认证**和**权限验证**是现在每个涉及到用户登录的系统都不必不可缺的。

本文会简单介绍登录认证和权限认证相关的知识，以及如何使用`springsecurity`框架实现相关功能。



### 基础知识

#### 登录认证

登录认证的概念非常简单，主要是处理两个问题，**登录密码校验**和**验证登录状态**

##### 登录密码校验

系统一般都有登录界面，用户在登录界面输入用户名和登录密码。

那么我们要做的就是根据用户名，去用户数据库中查询到用户的密码，然后将数据库中的密码与用户输入的密码进行比对。如果相同，那么登录成功，如果不同，则提示账号密码错误。

##### 认证登录状态

我们要知道`HTTP`请求是一个**无状态**协议，即每次的请求都是相互独立的。服务器不会知晓你之前的行为，只会看到你当前的请求。

所以我们需要一种机制能够将用户的登录状态保存下来，即**凭证**。用户登录之后，每次发送请求的同时携带该凭证，那么服务器就可以通过这个凭证认证你的登录状态。

现在最常用的便是使用`Session`，`Token`，`Cookie`携带凭证。

###### Session

`session`即会话，用户访问服务器是便是与服务器产生了一次`session`。服务器为了记住该用户，则在服务器上使用`session`存储这个用户的信息。

`session`不会随着浏览器的关闭而消失，他具有可定义失效日期，失效后服务器便认为与客户端断开联系，并删除`session`以节约空间。

`session`的缺点很明显，就是会占用服务器的存储空间。当服务器的访问较少时，`session`还是可行的，但是当有大量的访问时，便会占用服务器的负载和性能。

此外，对于分布式的系统，为了负载均衡，同一个访问会分配到不同的服务器，所以一个用户登录之后，将信息保存在登录时的服务器上，但是后续可能就被分配到另外的服务器上，这就导致要重新登录。这是非常不能接受的。

> 当然我们可以使用`springsession`实现分布式会话管理，实现`session`共享功能。

###### Cookie

为了解决`session`保存在服务器上的问题，`cookie`同样由服务器生成（与`session`一样，生成的是`session ID`），但是交由浏览器保存在客户端本地，以`key-value`形式存储用户信息。

其实就是写在客户端的一段`txt`文件，里面包括了你的登录信息，这样下次登录时就会自动调用`cookie`登录。

![](https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20210611133943.png)

这就是我使用`Chrome`浏览器中`github`上的`cookies`

> `name`（名字）+`value`（值）+`Domain`（域名）+`Path`（路径）+`Expires`（过期时间）+`Size`（大小）

`cookie`相较`session`对于服务器更加友好，但是由于存储在客户端，容易被修改，所以非常不安全

此外，`cookie`只能保存少量数据，而且是基于使用的浏览器而不同的，不同浏览器访问相同网页使用的`cookie`都是不同的。

###### Token

`token`是目前较为主流的一种凭证，他的基本思想便是提供一个加密和解密的功能

用户登录之后，根据一段数据，可以是用户名或者其他数据，加密成一段字符串，并返回给客户端。客户端脚本会将`token`储存起来，可以是存储到`cookie`也开始是`localStorage`

之后用户再次访问该域名时，便会将`token`放到 `Authorization header`中，此时服务器可以是对该`token`进行解密或者对数据进行再次加密，检查是否匹配。若解密成功或者匹配成功即实现登陆认证。

> 其实`cookie`和`session`只是将服务器生成的`session id`存储到了不同的地方，一个存储在服务器，一个存储在客户端。
>
> 而`token`和他们两个不同的是，`token`是无状态的，他不需要依赖`session`，即服务器不需要保存对`token`的记录，服务器只需要验证他的有效性即可。
>
> 此外，`session`和`cookie`很关键的问题就是跨域问题，因为产生的`session id`是依赖`session`的，所以不同`session`将导致登录认证失败。而`token`由于不依赖`session`所以完全可以实现`CORS(跨域资源共享)`

#### 权限验证

登录认证是对用户身份的认证，而权限认证则是在用户认证之后，对于该用户是否具有访问该接口或者执行该功能的权限的验证。

例如对于一个用户管理的系统，管理员具有对用户的`CRUD`的操作，而普通用户只具有查看的操作。所以当客户端发送请求的时候，我们就要验证该用户是否具有访问当前权限资源的权限。

往往我们将权限实现为权限资源，即对应的访问`url`（`/user/add`）和接口的请求`url`（`POST:/user/add`）

因此，我们将用户划分为几种不同的身份，例如超级管理员，管理员，普通用户等，每种身份对应不同的权限`id`，而每个权限`id`有对应其能访问的权限资源。

我们往往使用`Interceptor`进行权限验证，即每次向某个权限资源发出请求时，启动拦截器，获取用户的权限列表，验证该权限资源是否在用户权限列表当中，若不在则拒绝访问。

> 拦截器
>
> 拦截器其实就是`AOP`的一种运用，就是在某个切入点执行一个通知。例如权限验证，调用方法前打印出字符串等等。
>
> 过滤器
>
> 过滤器是对传入`servlet`之前的`request`或者之后的`response`进行业务逻辑处理，例如过滤掉危险字符等等。	



### SpringSecurity

`springboot`这类安全框架对于`web`系统的支持其实就是提供**基于一个个过滤组成的过滤器链**

<img src="https://typora-cwh.oss-cn-hangzhou.aliyuncs.com/20210611145109.png" style="zoom: 67%;" />

我们通过过滤器链中的过滤器完成相应的类似**登录认证**和**权限验证**的功能。

`springsecurity`的具体操作便是在过滤器链中添加一个`FilterChainProxy`过滤器，这个代理过滤器会为服务器创建一套`springsecurity`自定义的过滤器链。

这样便会启用`springsecurity`默认的一些过滤器，类似`UsernamePasswordAuthenticationFilter`负责登录认证，`FilterSecurityInterceptor`负责权限授权。

#### 登录认证

首先我们先介绍几个概念

------

`Authentication` ：`springsecurity`存储认证信息的组件，其中存储内容就是用户认证信息：

:bell:`Principal` 用户信息，没有认证时一般是用户名，认证后一般是用户对象。

:bell:`Credentials`用户凭证

:bell:`Authorities`用户权限

`SecurityContext`上下文对象，用来获取`Authentication`

`SecurityContextHolder`上下文管理对象，用来在程序任何地方获取`SecurityContext`

------

了解了这几个概念之后就很好理解`springsecurity`的认证流程了：

* 初次登录验证（验证密码是否相同）
* 登录之后设置`authentication`，将其放入上下文中，代表该用户已登录。

* 之后发出其他请求时，如果用户上下文中存在`authentication`即代表已登录。

了解了认证流程之后，我们具体来看下`springsecurity`是如何完成认证的：

`spring security`使用`AuthenticationManager`组件进行登录认证，其校验逻辑非常简单：

* 根据用户名查询出用户对象
* 将用户对象的密码与传入的密码进行校验

这里`spring security`又提供了三个组件

***

`UserDetails` : 通过该接口告知系统我们的用户对象数据，提供了用户名，密码，权限等通用属性，`spring security`为我们提供了一个实现类`User`，以避免重写多余方法，我们只需要继承`User`类，调用其构造方法初始化用户名，密码，权限即可。

`UserDetailsService` ：该接口提供`loadUserByusername`方法，用于通过用户名查询用户对象，我们只需要实现实现该接口，在`loadUserByusername()`完成我们的逻辑并返回`UserDetail`对象即可。

`PasswordEncoder`：用于密码加密。

***

